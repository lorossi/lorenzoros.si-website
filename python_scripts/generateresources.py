import json
import logging
from github import Github
from ftplib import FTP_TLS
from datetime import datetime


"""
    This script updates informations about background colors and GitHub repo.
    Since I don't have a VPS (I use normal hosting), I run this code every once
    in a while and update the result through FTP into the server,
    Every part is costumizable inside the file settings.json
"""

# Calculates hue of an rbg color. Inputs a string like #FFFFFF
def calculateHue(color):
    r = int(color[1:3], 16) / 255
    g = int(color[3:5], 16) / 255
    b = int(color[5:7], 16) / 255

    minval = min(r, g, b)
    maxval = max(r, g, b)
    if (r > g and r > b):
        # red is max
        hue = (g - b) / (maxval - minval)
    elif (g > r and g > b):
        # green is max
        hue = 2 + (b - r) / (maxval - minval)
    elif (b > r and b > g):
        # blue is max
        hue = 4 + (r - g) / (maxval - minval)
    else:
        hue = 0

    hue *= 60;
    if (hue < 0): hue += 360

    return hue

# Calculate brightness of a color
def averageColor(colors):
    r = [int(c[1:3], 16) for c in colors]
    g = [int(c[3:5], 16) for c in colors]
    b = [int(c[5:7], 16) for c in colors]

    average = []
    average.append((r[0] + r[1]) / 2)
    average.append((g[0] + g[1]) / 2)
    average.append((b[0] + b[1]) / 2)

    brightness = (0.2126 * average[0] + 0.7152 * average[1] + 0.0722 * average[2])
    return brightness

# Load settings from path
def loadSettings(path="settings.json"):
    path = "settings.json"
    with open(path) as json_file:
        settings = json.load(json_file)
    return settings


#def saveToFile(combinations, strings, repos, languages, lines_of_code, number_of_commits, path):
def saveToFile(**kwargs):
    newl = "\n"
    tab = "    "
    slash = "//"
    output_string = ""
    output_string += f"{slash} this is my poor man's VPS. Might upgrade, one day.{newl}"
    output_string += f"{slash} every resource you see in this file is generated by a Python script that I occasionally run.{newl}"
    output_string += f"{slash} as such, not everything on my website might be up to date.{newl}{newl}"

    output_string += f"{slash} variable containing gradient colors{newl}"
    output_string += "var colors = ["
    for c in kwargs["combinations"]:
        line = str(c)
        # convert to js notation
        line = line.replace("True", "true")
        line = line.replace("False", "false")
        output_string += f"{newl}{tab}{line},"
    # we remove last comma
    output_string = output_string[:-1]
    output_string += f"{newl}];{newl}{newl}"

    output_string += f"{slash} variable containing subtitles{newl}"
    output_string += "var strings = ["
    for s in kwargs["strings"]:
        line = str(s)
        output_string += f"{newl}{tab}'{line}',"
    output_string = output_string[:-1]
    output_string += f"{newl}];{newl}{newl}"

    output_string += f"{slash} variable containing infos about my repos{newl}"
    output_string += "var repos = ["
    for r in kwargs["repos"]:
        line = str(r)
        line = line.replace("None", "null")
        output_string += f"{newl}{tab}{line},"
    output_string = output_string[:-1]
    output_string += f"{newl}];{newl}{newl}"

    output_string += f"{slash} variable containing repos programming languages{newl}"
    output_string += "var languages = "
    output_string += f"{str(kwargs['languages'])};"
    output_string += f"{newl}{newl}"

    output_string += f"{slash} variable containing total bytes of code{newl}"
    output_string += f"var total_bytes = {kwargs['bytes_of_code']};"
    output_string += f"{newl}{newl}"

    output_string += f"{slash} variable containing total number of commits{newl}"
    output_string += f"var total_commits = {kwargs['number_of_commits']};"
    output_string += f"{newl}{newl}"

    output_string += f"{slash} variable containing total number of stars{newl}"
    output_string += f"var total_stars = {kwargs['stars']};"
    output_string += f"{newl}{newl}"

    output_string += f"{slash} variable containing total number of languages{newl}"
    output_string += f"var total_languages = {len(kwargs['languages'])};"
    output_string += f"{newl}{newl}"

    output_string += f"{slash} variable containing the timestamp of the last update{newl}"
    output_string += f"var timestamp = '{kwargs['updated_timestamp']}';"
    output_string += f"{newl}"

    output_file = open(kwargs["path"],"w+")
    output_file.write(output_string)
    output_file.close()
    return


def main():
    logging.basicConfig(filename='generateresources.log', level=logging.INFO,
                        format='%(asctime)s %(levelname)s %(message)s',
                        filemode="w")

    logging.info("started script")
    settings = loadSettings()
    logging.info("settings loaded")
    colors = settings["colors"]
    min_angle = settings["min_angle"]
    max_angle = settings["max_angle"]
    threshold_brightness = settings["threshold_brightness"]
    strings = settings["strings"]
    output_file = settings["output_file"]
    github_credentials = settings["GitHub"]
    ftp_credentials = settings["FTP"]

    # list that will hold every color combination
    colors_combinations = []

    # loop through colors
    for c1 in colors:
        # keep track of original list of colrs
        colors_copy = [c for c in colors]

        # calculate the hue of the first color
        c1_hue = calculateHue(c1)

        # loop through colors again
        for c2 in colors_copy:
            if c1 == c2:
                continue

            c2_hue = calculateHue(c2)
            angle_between = abs(c2_hue - c1_hue)
            if angle_between > min_angle and angle_between < max_angle:
                # the two colors are not too far (they are not complementary)
                brightness = averageColor([c1, c2])
                # we want to know if the gradient is "dark" or "light"
                bright = brightness > threshold_brightness

                new_dict = {
                    "from": c1,
                    "to": c2,
                    "bright": bright
                }

                check_old = {
                    "from": c2,
                    "to": c1,
                    "bright": bright
                }

                # we check if the couple hasn't been checked already
                if not check_old in colors_combinations:
                    colors_combinations.append(new_dict)

    logging.info("colors calculated")

    repos = []
    languages = {}
    relative_languages = {}
    total_bytes = 0
    total_commits = 0
    total_stars = 0

    g = Github(github_credentials["access_token"])
    logging.info("logged into GitHub")

    for repo in g.get_user().get_repos():
        if any(word in repo.name for word in github_credentials["skip_names"]):
            continue

        if any(url in repo.html_url for url in github_credentials["skip_urls"]):
            continue

        if not repo.language:
            language = ""
        else:
            language = repo.language

        repos.append({
            "name": repo.name,
            "formatted_name": repo.name.replace("-", " "),
            "url": repo.html_url,
            "commits": repo.get_commits().totalCount,
            "stars": repo.stargazers_count,
            "language": language,
            "last_pushed": repo.pushed_at,
            "last_pushed_timestamp": repo.pushed_at.strftime("%m-%d-%yT%H:%M:%S:%f"),
            "created": repo.created_at,
            "created_timestamp": repo.created_at.strftime("%m-%d-%yT%H:%M:%S:%f")
        })

        total_commits += repo.get_commits().totalCount
        total_stars += repo.stargazers_count

        repo_languages = repo.get_languages()
        for l in repo_languages:
            total_bytes += repo_languages[l]
            if l in languages:
                languages[l] += repo_languages[l]
            else:
                languages[l] = repo_languages[l]

    # sort by number of commits
    #repos = sorted(repos, key=lambda d: d['commits'], reverse=True)

    # sort by time
    repos = sorted(repos, key=lambda x : x['created'], reverse=True)

    # remove last updated datetime
    for r in repos:
        del r["last_pushed"]
        del r["created"]

    for l in languages:
        relative_languages[l] = round(languages[l] / total_bytes  * 100, 2)
    relative_languages = {k: v for k, v in sorted(relative_languages.items(), key=lambda item: item[1], reverse=True)}
    logging.info("repos loaded")

    updated_timestamp = datetime.now().isoformat()
    kwargs = {
        "combinations": colors_combinations,
        "strings": strings,
        "repos": repos,
        "languages": relative_languages,
        "stars": total_stars,
        "bytes_of_code": total_bytes,
        "number_of_commits": total_commits,
        "updated_timestamp": updated_timestamp,
        "path": output_file
    }

    saveToFile(**kwargs)
    logging.info("file saved")

    if ftp_credentials["upload"]:
        #time to upload to server
        ftp = FTP_TLS(ftp_credentials["server"])
        ftp.connect(port=ftp_credentials["port"])
        ftp.login(user=ftp_credentials["username"], passwd=ftp_credentials["password"])
        logging.info("connected to FTP")
        ftp.cwd(ftp_credentials["path"])
        file_path = settings["output_file"]

        if "/" in file_path:
            file_name = file_path.split("/")[-1]
        else:
            # file path is actually only a file name
            file_name = file_path

        # save file
        ftp.storlines("STOR " + file_name, open(file_path, 'rb'))
        logging.info("file uploaded")
        ftp.close()

    logging.info("done")

if __name__ == "__main__":
    main()
